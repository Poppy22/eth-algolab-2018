#include <iostream>
#include <vector>

#include <CGAL/Gmpz.h>
#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>


typedef CGAL::Gmpz ET;
typedef CGAL::Quadratic_program<ET> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;
typedef CGAL::Quotient<ET> objective_t;


struct Cell {
	int x, y, z;
};

int h, t;
std::vector<Cell> good;
std::vector<Cell> bad;

void read() {
	std::cin >> h >> t;
	good = std::vector<Cell>(h);
	bad = std::vector<Cell>(t);

	for (int i = 0; i < h; i++)
		std::cin >> good[i].x >> good[i].y >> good[i].z;
		//std::cout << good[i].x << good[i].y <<  ' ';

	for (int i = 0; i < t; i++)
		std::cin >> bad[i].x >> bad[i].y >> bad[i].z;
}


bool separable(int d) {
	Program lp(CGAL::EQUAL, false, 0, false, 0);

	for (int cell = 0; cell < h; cell++) {
		int var_index = 0;
		lp.set_b(cell, 1);
		lp.set_r(cell, CGAL::LARGER);
		double x = good[cell].x;
		double y = good[cell].y;
		double z = good[cell].z;
		double x_i, y_j, z_k;
		x_i = y_j = z_k = 1;
		for (int i = 0; i <= d; i++, x_i *= x) { // x^i
			y_j = 1;
			for (int j = 0; j <= d; j++, y_j *= y) { //y^j 
				z_k = 1;
				for (int k = 0; k <= d; k++, z_k *= z) {//z^k
					if (i + j + k > d) break;
					lp.set_a(var_index, cell, x_i * y_j * z_k);	
					var_index++;
				}
			}
		}
	}

	for (int cell = 0; cell < t; cell++) {
		int var_index = 0;
		lp.set_r(h + cell, CGAL::SMALLER);
		lp.set_b(h + cell, -1);
		double x = bad[cell].x;
		double y = bad[cell].y;
		double z = bad[cell].z;
		double x_i, y_j, z_k;
		x_i = y_j = z_k = 1;
		for (int i = 0; i <= d; i++, x_i *= x) { // x^i
			y_j = 1;
			for (int j = 0; j <= d; j++, y_j *= y) { //y^j 
				z_k = 1;
				for (int k = 0; k <= d; k++, z_k *= z) {//z^k
					if (i + j + k > d) break;
					lp.set_a(var_index, h + cell, x_i * y_j * z_k);
					var_index++;
				}
			}
		}
	}

	CGAL::Quadratic_program_options options;
	options.set_pricing_strategy(CGAL::QP_BLAND); 
	Solution s = CGAL::solve_linear_program(lp, ET(), options);
	return !s.is_infeasible();
}

void solve2() {
	/*int st = 1;
	int dr = 1;
	
	do {
      dr = dr * 2;
    } while(dr <= 30 && !separable(dr));

    st = dr / 2 - 1;
    dr = std::min(dr, 30);*/

    int st = 0;
    int dr = 30;

	int sol = -1;

	while (st <= dr) {
		// std::cout << st << ' ' << dr << '\n';
		int mid = (st + dr) / 2;
		if (separable(mid)) {
			sol = mid;
			dr = mid - 1;
		}
		else st = mid + 1; 
	}

	if (sol == -1) std::cout << "Impossible!" << '\n';
	else std::cout << sol << '\n';
}

int main() {
	std::ios_base::sync_with_stdio(false);
	int n;

	std::cin >> n;
	while(n--) {
		read();
		solve2();
	}

	return 0;
}